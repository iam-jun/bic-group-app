/*! markdown-it-emoji 2.0.0 https://github.com/markdown-it/markdown-it-emoji @license MIT */
!(function (e, t) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = t())
    : typeof define === 'function' && define.amd
      ? define(t)
      : ((e = typeof globalThis !== 'undefined'
        ? globalThis
        : e || self).markdownitEmoji = t());
}(this, () => {
  const e = function (e, t) {
    return e[t].content;
  };
  return function (t, n) {
    const r = (function (e) {
      let t;
      let n = e.defs;
      e.enabled.length
        && (n = Object.keys(n).reduce((t, r) => (e.enabled.indexOf(r) >= 0 && (t[r] = n[r]), t), {})),
      (t = Object.keys(e.shortcuts).reduce((t, r) => (n[r]
        ? Array.isArray(e.shortcuts[r])
          ? (e.shortcuts[r].forEach((e) => {
            t[e] = r;
          }),
          t)
          : ((t[e.shortcuts[r]] = r), t)
        : t), {}));
      let r;
      const o = Object.keys(n);
      r = o.length === 0
        ? '^$'
        : o
          .map((e) => `:${e}:`)
          .concat(Object.keys(t))
          .sort()
          .reverse()
          .map((e) => e.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'))
          .join('|');
      const c = RegExp(r);
      const s = RegExp(r, 'g');
      return {
        defs: n, shortcuts: t, scanRE: c, replaceRE: s,
      };
    }(t.utils.assign({}, { defs: {}, shortcuts: {}, enabled: [] }, n || {})));
    (t.renderer.rules.emoji = e),
    t.core.ruler.push(
      'emoji',
      (function (e, t, n, r, o) {
        const c = e.utils.arrayReplaceAt;
        const s = e.utils.lib.ucmicro;
        const u = new RegExp([s.Z.source, s.P.source, s.Cc.source].join('|'));
        function i(e, r, c) {
          let s;
          let i = 0;
          const l = [];
          return (
            e.replace(o, (r, o, f) => {
              let a;
              if (n.hasOwnProperty(r)) {
                if (((a = n[r]), o > 0 && !u.test(f[o - 1]))) return;
                if (o + r.length < f.length && !u.test(f[o + r.length])) return;
              } else a = r.slice(1, -1);
              o > i
                  && (((s = new c('text', '', 0)).content = e.slice(i, o)),
                  l.push(s)),
              ((s = new c('emoji', '', 0)).markup = a),
              (s.content = t[a]),
              l.push(s),
              (i = o + r.length);
            }),
            i < e.length
                && (((s = new c('text', '', 0)).content = e.slice(i)), l.push(s)),
            l
          );
        }
        return function (e) {
          let t;
          let n;
          let o;
          let s;
          let u;
          const l = e.tokens;
          let f = 0;
          for (n = 0, o = l.length; n < o; n++) {
            if (l[n].type === 'inline') {
              for (t = (s = l[n].children).length - 1; t >= 0; t--) {
                ((u = s[t]).type !== 'link_open'
                    && u.type !== 'link_close')
                    || (u.info === 'auto' && (f -= u.nesting)),
                u.type === 'text'
                      && f === 0
                      && r.test(u.content)
                      && (l[n].children = s = c(s, t, i(u.content, u.level, e.Token)));
              }
            }
          }
        };
      }(t, r.defs, r.shortcuts, r.scanRE, r.replaceRE)),
    );
  };
}));
